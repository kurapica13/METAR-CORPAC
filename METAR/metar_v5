"""
METAR DIGITAL WEB - VERSI√ìN PROFESIONAL CORPAC PER√ö
Aeropuerto Internacional Jorge Ch√°vez (SPJC)
Caracter√≠sticas:
‚úÖ Viento con reglas circulares (340V080)
‚úÖ Visibilidad m√≠nima con cuadrantes (N, NE, E, SE, S, SW, W, NW)
‚úÖ RVR (Runway Visual Range)
‚úÖ Est√°ndar oficial nubes CORPAC (30m/1000m)
‚úÖ Fen√≥menos especiales (PRFG, VCFG, BCFG, MIFG)
‚úÖ Excel con formato profesional - Una hoja por d√≠a
‚úÖ Sin duplicados - Reemplaza reportes con misma fecha/hora
‚úÖ D√çA CORREGIDO - Respeta el d√≠a ingresado por el usuario
"""

import streamlit as st
from datetime import datetime, timezone
import pandas as pd
from pathlib import Path
import re
import time
import os
import base64
from io import BytesIO

# ============================================
# CONFIGURACI√ìN DE P√ÅGINA
# ============================================
st.set_page_config(
    page_title="METAR Digital - CORPAC Per√∫",
    page_icon="‚úàÔ∏è",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# Limpiar cach√© al inicio
st.cache_data.clear()

# ============================================
# ESTILOS CSS PERSONALIZADOS
# ============================================
st.markdown("""
<style>
    .stApp {
        background-color: #f0f8ff;
    }
    
    .metar-header {
        background: linear-gradient(90deg, #0b3d91 0%, #1a4fa0 100%);
        padding: 1.5rem;
        border-radius: 10px;
        color: white;
        margin-bottom: 2rem;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .panel {
        background: white;
        padding: 1.5rem;
        border-radius: 10px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        margin-bottom: 1rem;
    }
    
    .section-title {
        color: #0b3d91;
        font-weight: 600;
        margin-bottom: 1rem;
        border-bottom: 2px solid #e8eef7;
        padding-bottom: 0.5rem;
    }
    
    .metar-box {
        background: #1e1e1e;
        color: #00ff00;
        padding: 1rem;
        border-radius: 5px;
        font-family: 'Courier New', monospace;
        font-size: 1.1rem;
        border-left: 5px solid #0b3d91;
    }
    
    .historial-item {
        background: #f8f9fa;
        padding: 0.8rem;
        margin-bottom: 0.5rem;
        border-radius: 3px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        border-left: 3px solid #0b3d91;
    }
    
    .historial-item-speci {
        background: #FFE699;
        border-left: 3px solid #FFC000;
    }
    
    .stButton button {
        width: 100%;
        border-radius: 5px;
        font-weight: 600;
    }
    
    .stTextInput input, .stSelectbox select {
        border-radius: 5px;
        border: 1px solid #ddd;
    }
    
    .dia-actual {
        background-color: #e8f4f8;
        padding: 5px 10px;
        border-radius: 5px;
        font-weight: bold;
        color: #0b3d91;
        margin-bottom: 10px;
    }
</style>
""", unsafe_allow_html=True)

# ============================================
# INICIALIZAR ESTADO DE SESI√ìN
# ============================================
if 'registros' not in st.session_state:
    st.session_state.registros = []
if 'historial' not in st.session_state:
    st.session_state.historial = []
if 'contador' not in st.session_state:
    st.session_state.contador = 0
if 'campos_inicializados' not in st.session_state:
    st.session_state.campos_inicializados = False

# ============================================
# FUNCI√ìN PARA LIMPIAR CAMPOS - CORREGIDA
# ============================================
def limpiar_campos():
    """Limpia todos los campos del formulario - RESPETA EL D√çA INGRESADO"""
    # NO modificar el d√≠a - mantener el que el usuario ingres√≥
    if 'dia_input' in st.session_state:
        st.session_state.dia_actual = st.session_state.dia_input
    else:
        st.session_state.dia_actual = datetime.now(timezone.utc).strftime("%d")
    
    # Solo resetear hora a la actual
    st.session_state.hora = datetime.now(timezone.utc).strftime("%H%M")
    
    # Limpiar el resto de campos
    st.session_state.tipo = "METAR"
    st.session_state.dir_viento = ""
    st.session_state.int_viento = ""
    st.session_state.var_viento = ""
    st.session_state.vis = ""
    st.session_state.vis_min = ""
    st.session_state.rvr = ""
    st.session_state.fenomeno = ""
    st.session_state.nubes = ""
    st.session_state.temp = ""
    st.session_state.rocio = ""
    st.session_state.hr = ""
    st.session_state.qnh = ""
    st.session_state.presion = ""
    st.session_state.suplementaria = ""
    st.session_state.campos_inicializados = True

# ============================================
# INICIALIZAR CAMPOS VAC√çOS - CORREGIDO
# ============================================
if not st.session_state.campos_inicializados:
    # Inicializar d√≠a solo si no existe
    if 'dia_actual' not in st.session_state:
        st.session_state.dia_actual = datetime.now(timezone.utc).strftime("%d")
    if 'hora' not in st.session_state:
        st.session_state.hora = datetime.now(timezone.utc).strftime("%H%M")
    if 'tipo' not in st.session_state:
        st.session_state.tipo = "METAR"
    
    limpiar_campos()

# ============================================
# FUNCI√ìN PARA ACTUALIZAR O INSERTAR REGISTRO
# ============================================
def actualizar_o_insertar_registro(registros, nuevo_registro):
    """Busca un registro existente con el mismo d√≠a y hora. Si existe, lo reemplaza."""
    dia_hora_clave = f"{nuevo_registro['D√≠a']}_{nuevo_registro['Hora']}"
    
    for i, registro in enumerate(registros):
        clave_existente = f"{registro.get('D√≠a', '')}_{registro.get('Hora', '')}"
        if clave_existente == dia_hora_clave:
            registros[i] = nuevo_registro
            return "actualizado"
    
    registros.insert(0, nuevo_registro)
    return "insertado"

# ============================================
# FUNCIONES DE PROCESAMIENTO - VIENTO
# ============================================
def procesar_viento(direccion, intensidad, variacion):
    """
    PROCESAMIENTO DE VIENTO - REGLAS CORPAC PER√ö
    Caso 1: Variaci√≥n ‚â•60¬∞ y <180¬∞ con viento <3kt ‚Üí VRBxxKT
    Caso 2: Variaci√≥n ‚â•60¬∞ y <180¬∞ con viento ‚â•3kt ‚Üí dddffKT bbbVnnn
    Caso 3: Variaci√≥n ‚â•180¬∞ ‚Üí VRBxxKT
    """
    dir_int = int(direccion)
    intensidad_str = str(intensidad).upper().strip()
    
    if 'G' in intensidad_str:
        if 'G' in intensidad_str and not ' ' in intensidad_str.replace('G', ''):
            base_int, gust_int = intensidad_str.split('G')
            int_base = int(base_int)
            int_gust = int(gust_int)
            intensidad_metar = f"{int_base:02d}G{int_gust:02d}"
        else:
            parts = intensidad_str.replace('G', ' ').split()
            int_base = int(parts[0])
            int_gust = int(parts[1])
            intensidad_metar = f"{int_base:02d}G{int_gust:02d}"
    else:
        int_base = int(intensidad_str)
        intensidad_metar = f"{int_base:02d}"
    
    if not variacion:
        return f"{dir_int:03d}{intensidad_metar}KT"
    
    try:
        variacion = variacion.upper().replace(' ', '')
        if 'V' not in variacion:
            return f"{dir_int:03d}{intensidad_metar}KT"
        
        desde, hasta = map(int, variacion.split('V'))
        
        diff1 = abs(hasta - desde)
        diff2 = 360 - diff1
        diferencia = min(diff1, diff2)
        
        if diferencia >= 180:
            return f"VRB{intensidad_metar}KT"
        
        if diferencia >= 60:
            if int_base < 3:
                return f"VRB{intensidad_metar}KT"
            else:
                if diff1 <= 180:
                    return f"{dir_int:03d}{intensidad_metar}KT {desde:03d}V{hasta:03d}"
                else:
                    return f"{dir_int:03d}{intensidad_metar}KT {hasta:03d}V{desde:03d}"
        
        return f"{dir_int:03d}{intensidad_metar}KT {variacion}"
        
    except Exception as e:
        return f"{dir_int:03d}{intensidad_metar}KT"

# ============================================
# FUNCIONES DE PROCESAMIENTO - VISIBILIDAD
# ============================================
def convertir_visibilidad(vis_texto):
    """Convierte visibilidad a metros"""
    vis_texto = vis_texto.strip().upper()
    if not vis_texto:
        raise ValueError("Visibilidad es obligatoria")
    
    try:
        if vis_texto.endswith("KM"):
            km = float(vis_texto[:-2])
            return 9999 if km >= 10 else int(km * 1000)
        elif vis_texto.endswith("M"):
            return int(vis_texto[:-1])
        else:
            metros = int(vis_texto)
            return 9999 if metros >= 10000 else metros
    except:
        raise ValueError("Formato de visibilidad inv√°lido")

def procesar_visibilidad_minima(vis_min_texto, vis_m):
    """
    Procesa visibilidad m√≠nima con cuadrantes
    Cuadrantes: N, NE, E, SE, S, SW, W, NW
    """
    if not vis_min_texto:
        return "", ""
    
    vis_min_texto = vis_min_texto.strip().upper()
    
    # Priorizar cuadrantes de 2 letras
    if vis_min_texto.endswith('NW'):
        valor = vis_min_texto[:-2]
        cuadrante = 'NW'
    elif vis_min_texto.endswith('NE'):
        valor = vis_min_texto[:-2]
        cuadrante = 'NE'
    elif vis_min_texto.endswith('SW'):
        valor = vis_min_texto[:-2]
        cuadrante = 'SW'
    elif vis_min_texto.endswith('SE'):
        valor = vis_min_texto[:-2]
        cuadrante = 'SE'
    elif vis_min_texto.endswith('N'):
        valor = vis_min_texto[:-1]
        cuadrante = 'N'
    elif vis_min_texto.endswith('S'):
        valor = vis_min_texto[:-1]
        cuadrante = 'S'
    elif vis_min_texto.endswith('E'):
        valor = vis_min_texto[:-1]
        cuadrante = 'E'
    elif vis_min_texto.endswith('W'):
        valor = vis_min_texto[:-1]
        cuadrante = 'W'
    else:
        valor = vis_min_texto
        cuadrante = ''
    
    try:
        if valor.endswith("KM"):
            km = float(valor[:-2])
            vis_min_m = 9999 if km >= 10 else int(km * 1000)
        elif valor.endswith("M"):
            vis_min_m = int(valor[:-1])
        else:
            vis_min_m = int(valor)
            vis_min_m = 9999 if vis_min_m >= 10000 else vis_min_m
        
        es_valida = False
        if vis_min_m < 1500:
            es_valida = True
        if vis_min_m < (vis_m * 0.5) and vis_min_m < 5000:
            es_valida = True
        
        if not es_valida:
            return "", "‚ö†Ô∏è No cumple reglas de visibilidad m√≠nima"
        
        if cuadrante:
            return f"{vis_min_m:04d}{cuadrante}", ""
        else:
            return f"{vis_min_m:04d}", ""
        
    except:
        return "", "‚ùå Formato inv√°lido"

def procesar_rvr(rvr_texto):
    """Procesa RVR"""
    if not rvr_texto:
        return ""
    
    rvr_texto = rvr_texto.strip().upper().replace('M', '').replace('RVR', '')
    
    try:
        rvr_valor = int(rvr_texto)
        if rvr_valor < 50 or rvr_valor > 2000:
            return ""
        return f"RVR{rvr_valor:04d}"
    except:
        return ""

# ============================================
# FUNCIONES DE PROCESAMIENTO - FEN√ìMENOS
# ============================================
def codificar_fenomenos(texto):
    """CODIFICADOR DE FEN√ìMENOS"""
    if not texto:
        return ""
    
    texto_lower = texto.lower().strip()
    
    if any(x in texto_lower for x in ["niebla parcial", "prfg", "pr fg", "parcial"]):
        return "PRFG"
    if any(x in texto_lower for x in ["niebla en la vecindad", "vcfg", "vc fg", "vecindad"]):
        return "VCFG"
    if any(x in texto_lower for x in ["niebla en bancos", "bcfg", "bc fg", "bancos"]):
        return "BCFG"
    if any(x in texto_lower for x in ["niebla baja", "mifg", "mi fg", "baja"]):
        return "MIFG"
    
    intensidades = {"ligera": "-", "ligero": "-", "leve": "-", "d√©bil": "-",
                   "fuerte": "+", "intensa": "+", "intenso": "+", "severa": "+"}
    
    descriptores = {"sh": "SH", "chubasco": "SH", "ts": "TS", "tormenta": "TS",
                   "fz": "FZ", "helada": "FZ", "congelante": "FZ"}
    
    fenomenos = {
        "lluvia": "RA", "llovizna": "DZ", "niebla": "FG", "neblina": "BR",
        "nieve": "SN", "granizo": "GR", "cellisca": "GS", "tormenta": "TS",
        "polvo": "DU", "arena": "SA", "humo": "FU", "ceniza": "VA", "calima": "HZ"
    }
    
    partes = [p.strip() for p in texto.split(",")][:3]
    resultados = []
    
    for parte in partes:
        if not parte:
            continue
        parte_lower = parte.lower()
        codigo = ""
        descriptor = ""
        intensidad = ""
        
        for d_texto, d_codigo in descriptores.items():
            if d_texto in parte_lower:
                descriptor = d_codigo
                parte_lower = parte_lower.replace(d_texto, "").strip()
                break
        
        for i_texto, i_codigo in intensidades.items():
            if i_texto in parte_lower:
                intensidad = i_codigo
                parte_lower = parte_lower.replace(i_texto, "").strip()
                break
        
        for f_texto, f_codigo in fenomenos.items():
            if f_texto in parte_lower:
                codigo = f_codigo
                break
        
        if codigo:
            if descriptor:
                codigo = descriptor + codigo
            if intensidad:
                codigo = intensidad + codigo
            resultados.append(codigo)
    
    return " ".join(resultados) if resultados else ""

# ============================================
# FUNCIONES DE PROCESAMIENTO - NUBES
# ============================================
def interpretar_nubes(texto, vis_m, fenomeno):
    """CODIFICADOR DE NUBES - EST√ÅNDAR CORPAC"""
    texto = texto.strip().upper()
    
    if texto in ["DESPEJADO", "SKC", "CLR", "", "NSC", "SIN NUBES", "NO NUBES"]:
        return "NSC"
    
    if vis_m >= 9999 and not fenomeno.strip() and texto in ["NSC", "SKC", "CLR", "DESPEJADO"]:
        return "CAVOK"
    
    tipos_nubes = {
        "CU": "CU", "SC": "SC", "ST": "ST", "CB": "CB", "TCU": "TCU",
        "AC": "AC", "AS": "AS", "NS": "NS", "CI": "CI"
    }
    
    capas = texto.split(",")
    codigos_nubes = []
    
    for capa in capas[:4]:
        capa = capa.strip()
        if not capa:
            continue
        
        patron = r'(\d+)\s+([A-Z]{2,4})\s+(\d+)(?:M)?'
        match = re.search(patron, capa)
        
        if match:
            cantidad = int(match.group(1))
            tipo = match.group(2)
            altura = int(match.group(3))
            tipo_nube = tipos_nubes.get(tipo, tipo)
            
            if altura <= 3000:
                if altura % 30 != 0:
                    altura = (altura // 30) * 30
                altura_cientos = altura // 30
            else:
                if altura % 1000 != 0:
                    altura = (altura // 1000) * 1000
                altura_cientos = (altura // 1000) * 32
            
            altura_cientos = min(max(altura_cientos, 1), 999)
            
            if cantidad <= 2:
                cod_cant = "FEW"
            elif cantidad <= 4:
                cod_cant = "SCT"
            elif cantidad <= 7:
                cod_cant = "BKN"
            else:
                cod_cant = "OVC"
            
            codigo = f"{cod_cant}{altura_cientos:03d}"
            if tipo_nube in ["CB", "TCU"]:
                codigo += tipo_nube
            codigos_nubes.append(codigo)
    
    return " ".join(codigos_nubes[:4]) if codigos_nubes else "NSC"

def verificar_cavok(vis_m, fenomeno, nubes):
    """Verifica condiciones para CAVOK"""
    return (vis_m >= 9999 and not fenomeno.strip() and nubes in ["NSC", "SKC", "CLR"])

# ============================================
# FUNCIONES DE VALIDACI√ìN
# ============================================
def validar_hora(hora_str):
    if len(hora_str) != 4 or not hora_str.isdigit():
        raise ValueError("Hora debe ser HHMM (4 d√≠gitos)")
    h = int(hora_str[:2])
    m = int(hora_str[2:])
    if h > 23 or m > 59:
        raise ValueError("Hora inv√°lida")
    return hora_str

def validar_intensidad_viento(intensidad_str):
    intensidad_str = str(intensidad_str).strip().upper()
    if not intensidad_str:
        raise ValueError("Intensidad de viento requerida")
    
    intensidad_str = intensidad_str.replace(' G ', 'G').replace(' G', 'G').replace('G ', 'G')
    
    if 'G' in intensidad_str:
        partes = intensidad_str.split('G')
        if len(partes) != 2:
            raise ValueError("Formato de r√°fagas inv√°lido. Use: 15G25")
        base = int(partes[0])
        rafaga = int(partes[1])
        if base < 0 or base > 100:
            raise ValueError("Intensidad base fuera de rango (0-100)")
        if rafaga < base:
            raise ValueError("R√°faga debe ser mayor o igual a intensidad base")
        if rafaga > 150:
            raise ValueError("R√°faga excede l√≠mite (150 KT)")
        diferencia = rafaga - base
        if diferencia < 10:
            raise ValueError(f"R√°faga requiere diferencia ‚â•10 KT (actual: {diferencia} KT)")
        return intensidad_str
    else:
        intensidad = int(intensidad_str)
        if intensidad < 0 or intensidad > 100:
            raise ValueError("Intensidad fuera de rango (0-100)")
        return intensidad_str

def validar_numero(valor, min_val, max_val, nombre):
    if not valor:
        raise ValueError(f"{nombre} es obligatorio")
    try:
        num = float(valor)
        if not (min_val <= num <= max_val):
            raise ValueError(f"{nombre} fuera de rango ({min_val}-{max_val})")
        return num
    except:
        raise ValueError(f"{nombre} inv√°lido")

def validar_temp_rocio(temp, rocio):
    if float(rocio) > float(temp):
        raise ValueError(f"Roc√≠o ({rocio}¬∞C) no puede ser > Temperatura ({temp}¬∞C)")
    return True

# ============================================
# FUNCI√ìN PRINCIPAL DE GENERACI√ìN
# ============================================
def generar_metar(datos):
    try:
        if not datos['dir_viento'] or not datos['int_viento']:
            raise ValueError("Direcci√≥n e intensidad del viento son obligatorias")
        if not datos['vis']:
            raise ValueError("Visibilidad es obligatoria")
        if not datos['temp'] or not datos['rocio'] or not datos['qnh']:
            raise ValueError("Temperatura, Roc√≠o y QNH son obligatorios")
        
        hora = validar_hora(datos['hora'])
        int_viento = validar_intensidad_viento(datos['int_viento'])
        viento = procesar_viento(datos['dir_viento'], int_viento, datos['var_viento'])
        vis_m = convertir_visibilidad(datos['vis'])
        
        vis_min_codigo = ""
        if datos['vis_min']:
            vis_min_codigo, vis_min_error = procesar_visibilidad_minima(datos['vis_min'], vis_m)
            if vis_min_error:
                raise ValueError(vis_min_error)
        
        rvr_codigo = procesar_rvr(datos['rvr'])
        fenomeno = codificar_fenomenos(datos['fenomeno'])
        nubes = interpretar_nubes(datos['nubes'], vis_m, fenomeno)
        
        temp = validar_numero(datos['temp'], -10, 40, "Temperatura")
        rocio = validar_numero(datos['rocio'], -10, 40, "Punto de roc√≠o")
        validar_temp_rocio(temp, rocio)
        qnh = validar_numero(datos['qnh'], 850, 1100, "QNH")
        
        es_cavok = verificar_cavok(vis_m, fenomeno, nubes)
        
        metar_parts = [f"{datos['tipo']} SPJC {datos['dia']}{hora}Z {viento}"]
        
        if es_cavok:
            metar_parts.append("CAVOK")
        else:
            metar_parts.append(f"{vis_m:04d}")
            if vis_min_codigo:
                metar_parts.append(vis_min_codigo)
            if rvr_codigo:
                metar_parts.append(rvr_codigo)
            if fenomeno:
                metar_parts.append(fenomeno)
            metar_parts.append(nubes)
        
        metar_parts.append(f"{round(temp):02d}/{round(rocio):02d} Q{round(qnh)}")
        
        if datos['suplementaria']:
            metar_parts.append(datos['suplementaria'].upper())
        
        metar_completo = " ".join(metar_parts) + "="
        
        registro = {
            'D√≠a': datos['dia'],
            'Hora': hora,
            'Tipo': datos['tipo'],
            'Direcci√≥n_Viento': datos['dir_viento'],
            'Intensidad_Viento': datos['int_viento'],
            'Variaci√≥n_Viento': datos['var_viento'],
            'Visibilidad_Original': datos['vis'],
            'Visibilidad_Metros': vis_m,
            'Visibilidad_M√≠nima': vis_min_codigo,
            'RVR': rvr_codigo,
            'Fen√≥meno_Texto': datos['fenomeno'],
            'Fen√≥meno_C√≥digo': fenomeno,
            'Nubes_Texto': datos['nubes'],
            'Nubes_C√≥digo': "CAVOK" if es_cavok else nubes,
            'Temperatura': temp,
            'Punto_Roc√≠o': rocio,
            'Humedad_Relativa_%': datos['hr'] if datos['hr'] else "",
            'QNH': qnh,
            'Presi√≥n_Estaci√≥n': datos['presion'],
            'Info_Suplementaria': datos['suplementaria'],
            'METAR_Completo': metar_completo
        }
        
        return {
            'success': True,
            'metar': metar_completo,
            'registro': registro
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }

# ============================================
# FUNCI√ìN PARA EXPORTAR EXCEL - HOJAS POR D√çA
# ============================================
def exportar_a_excel(registros):
    """Exporta registros a Excel con una hoja por cada d√≠a"""
    if not registros:
        return None, "No hay registros para exportar"
    
    try:
        # Convertir a DataFrame
        df = pd.DataFrame(registros)
        
        # Renombrar columnas para mejor presentaci√≥n
        df = df.rename(columns={
            'D√≠a': 'DIA',
            'Hora': 'HORA',
            'Tipo': 'TIPO',
            'Direcci√≥n_Viento': 'DIR VIENTO',
            'Intensidad_Viento': 'INTENSIDAD',
            'Variaci√≥n_Viento': 'VARIACION',
            'Visibilidad_Original': 'VIS (ORIGINAL)',
            'Visibilidad_Metros': 'VIS (CODIGO)',
            'Visibilidad_M√≠nima': 'VIS MIN',
            'RVR': 'RVR',
            'Fen√≥meno_Texto': 'FENOMENO',
            'Fen√≥meno_C√≥digo': 'WX',
            'Nubes_Texto': 'NUBOSIDAD',
            'Nubes_C√≥digo': 'CLD',
            'Temperatura': 'TEMP ¬∞C',
            'Punto_Roc√≠o': 'ROC√çO ¬∞C',
            'Humedad_Relativa_%': 'HR %',
            'QNH': 'QNH',
            'Presi√≥n_Estaci√≥n': 'PRESION',
            'Info_Suplementaria': 'RMK',
            'METAR_Completo': 'METAR'
        })
        
        # Formatear D√çA y HORA
        df['DIA'] = df['DIA'].astype(str).str.zfill(2)
        df['HORA'] = df['HORA'].astype(str).str.zfill(4)
        
        # Obtener lista de d√≠as √∫nicos (orden descendente)
        dias_unicos = sorted(df['DIA'].unique(), reverse=True)
        
        # Crear archivo Excel con m√∫ltiples hojas
        output = BytesIO()
        with pd.ExcelWriter(output, engine='openpyxl') as writer:
            
            from openpyxl.utils import get_column_letter
            from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
            
            # Estilos reutilizables
            header_font = Font(name='Calibri', size=11, bold=True, color='FFFFFF')
            header_fill = PatternFill(start_color='0B3D91', end_color='0B3D91', fill_type='solid')
            header_align = Alignment(horizontal='center', vertical='center', wrap_text=True)
            
            border = Border(
                left=Side(style='thin', color='CCCCCC'),
                right=Side(style='thin', color='CCCCCC'),
                top=Side(style='thin', color='CCCCCC'),
                bottom=Side(style='thin', color='CCCCCC')
            )
            
            # Crear una hoja por cada d√≠a
            for dia in dias_unicos:
                # Filtrar registros del d√≠a
                df_dia = df[df['DIA'] == dia].copy()
                
                # Ordenar por hora (m√°s reciente primero)
                df_dia = df_dia.sort_values('HORA', ascending=False)
                
                # Nombre de la hoja: DIA_12, DIA_13, etc.
                sheet_name = f"DIA_{dia}"
                
                # Escribir a Excel
                df_dia.to_excel(writer, sheet_name=sheet_name, index=False)
                worksheet = writer.sheets[sheet_name]
                
                # --- FORMATO DE CABECERA ---
                for col in range(1, len(df_dia.columns) + 1):
                    cell = worksheet.cell(row=1, column=col)
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.alignment = header_align
                
                worksheet.row_dimensions[1].height = 30
                
                # --- ANCHO AUTOM√ÅTICO DE COLUMNAS ---
                for col in range(1, len(df_dia.columns) + 1):
                    column_letter = get_column_letter(col)
                    max_length = 0
                    
                    # Cabecera
                    header_cell = worksheet.cell(row=1, column=col)
                    max_length = len(str(header_cell.value)) if header_cell.value else 0
                    
                    # Datos (primeros 100 registros)
                    for row in range(2, min(len(df_dia) + 2, 102)):
                        cell = worksheet.cell(row=row, column=col)
                        if cell.value:
                            cell_length = len(str(cell.value))
                            if cell_length > max_length:
                                max_length = cell_length
                    
                    adjusted_width = min(max_length + 2, 70)
                    worksheet.column_dimensions[column_letter].width = max(adjusted_width, 8)
                
                # --- FORMATO DE DATOS ---
                for row in range(2, len(df_dia) + 2):
                    tipo_reporte = worksheet.cell(row=row, column=3).value  # Columna TIPO
                    
                    for col in range(1, len(df_dia.columns) + 1):
                        cell = worksheet.cell(row=row, column=col)
                        cell.border = border
                        cell.alignment = Alignment(horizontal='center', vertical='center')
                        
                        # Formato especial para SPECI
                        if tipo_reporte == 'SPECI':
                            cell.fill = PatternFill(start_color='FFE699', end_color='FFE699', fill_type='solid')
                            cell.font = Font(name='Calibri', size=10, bold=True)
                        else:
                            cell.font = Font(name='Calibri', size=10)
                
                # Congelar paneles
                worksheet.freeze_panes = 'A2'
            
            # --- HOJA DE RESUMEN ---
            resumen_data = []
            for dia in dias_unicos:
                df_dia = df[df['DIA'] == dia]
                metar_count = len(df_dia[df_dia['TIPO'] == 'METAR'])
                speci_count = len(df_dia[df_dia['TIPO'] == 'SPECI'])
                
                # Obtener primera y √∫ltima hora
                primera_hora = df_dia['HORA'].min()
                ultima_hora = df_dia['HORA'].max()
                
                resumen_data.append({
                    'D√çA': dia,
                    'METAR': metar_count,
                    'SPECI': speci_count,
                    'TOTAL': len(df_dia),
                    'PRIMER REPORTE': f"{primera_hora[:2]}:{primera_hora[2:]}Z",
                    '√öLTIMO REPORTE': f"{ultima_hora[:2]}:{ultima_hora[2:]}Z"
                })
            
            df_resumen = pd.DataFrame(resumen_data)
            df_resumen = df_resumen.sort_values('D√çA', ascending=False)
            df_resumen.to_excel(writer, sheet_name='RESUMEN', index=False)
            
            # Formato de la hoja resumen
            worksheet_resumen = writer.sheets['RESUMEN']
            for col in range(1, len(df_resumen.columns) + 1):
                cell = worksheet_resumen.cell(row=1, column=col)
                cell.font = header_font
                cell.fill = header_fill
                cell.alignment = header_align
            
            # Ancho autom√°tico para resumen
            for col in range(1, len(df_resumen.columns) + 1):
                column_letter = get_column_letter(col)
                worksheet_resumen.column_dimensions[column_letter].width = 18
        
        output.seek(0)
        
        # Mensaje de √©xito
        total_dias = len(dias_unicos)
        total_registros = len(registros)
        
        if total_dias == 1:
            dias_msg = f"1 d√≠a (D√çA {dias_unicos[0]})"
        else:
            dias_msg = f"{total_dias} d√≠as: D√çA {dias_unicos[0]} al D√çA {dias_unicos[-1]}"
        
        mensaje = f"‚úÖ {total_registros} registros exportados\n"
        mensaje += f"üìÖ {dias_msg}\n"
        mensaje += f"üìä {len([r for r in registros if r.get('Tipo') == 'METAR'])} METAR | "
        mensaje += f"{len([r for r in registros if r.get('Tipo') == 'SPECI'])} SPECI"
        
        return output, mensaje
        
    except Exception as e:
        import traceback
        print(traceback.format_exc())
        return None, f"Error al exportar: {str(e)}"

# ============================================
# INTERFAZ DE USUARIO - CORREGIDA
# ============================================
col_header1, col_header2 = st.columns([3, 1])
with col_header1:
    st.markdown("<h1 style='color: #0b3d91;'>‚úàÔ∏è METAR DIGITAL - SPJC</h1>", unsafe_allow_html=True)
    st.markdown("<p style='color: #666;'>Aeropuerto Internacional Jorge Ch√°vez - CORPAC Per√∫</p>", unsafe_allow_html=True)

with col_header2:
    ahora = datetime.now(timezone.utc).strftime("%H:%M:%S")
    st.markdown(f"<h3 style='color: #0b3d91; text-align: right;'>UTC {ahora}</h3>", unsafe_allow_html=True)
    st.markdown(f"<p style='color: #666; text-align: right;'>{datetime.now().strftime('%d/%m/%Y')}</p>", unsafe_allow_html=True)

st.markdown("---")

col_izq, col_der = st.columns([2, 1])

with col_izq:
    with st.form(key='metar_form'):
        st.subheader("üìã DATOS DEL REPORTE")
        
        # INDICADOR DE D√çA ACTUAL
        dia_actual_display = st.session_state.get('dia_actual', datetime.now(timezone.utc).strftime("%d"))
        st.markdown(f"<div class='dia-actual'>üìÖ D√çA DE OBSERVACI√ìN: {dia_actual_display}</div>", unsafe_allow_html=True)
        
        col1, col2, col3 = st.columns(3)
        with col1:
            dia = st.text_input(
                "D√≠a", 
                value=st.session_state.get('dia_actual', datetime.now(timezone.utc).strftime("%d")),
                key='dia_input',
                help="D√≠a del mes (01-31)"
            )
            st.session_state.dia_actual = dia
            
        with col2:
            hora = st.text_input(
                "Hora UTC", 
                value=st.session_state.get('hora', datetime.now(timezone.utc).strftime("%H%M")),
                key='hora',
                help="Formato HHMM"
            )
        with col3:
            tipo = st.selectbox(
                "Tipo", 
                ["METAR", "SPECI"], 
                index=0 if st.session_state.get('tipo', 'METAR') == "METAR" else 1,
                key='tipo'
            )
        
        st.markdown("---")
        
        st.subheader("üí® VIENTO")
        col1, col2, col3 = st.columns(3)
        with col1:
            dir_viento = st.text_input("Direcci√≥n", key='dir_viento', help="Grados (0-360)")
        with col2:
            int_viento = st.text_input("Intensidad (KT)", key='int_viento', help="Nudos. R√°fagas: 15G25")
        with col3:
            var_viento = st.text_input("Variaci√≥n", key='var_viento', help="Formato: 340V080")
        
        st.markdown("---")
        
        st.subheader("üëÅÔ∏è VISIBILIDAD")
        col1, col2, col3 = st.columns(3)
        with col1:
            vis = st.text_input("Visibilidad", key='vis', help="Ej: 10km, 5000m, 9999")
        with col2:
            vis_min = st.text_input("Visibilidad M√≠nima", key='vis_min', help="Ej: 1200SW, 0800NE, 1500SE, 2000NW")
        with col3:
            rvr = st.text_input("RVR (m)", key='rvr', help="Runway Visual Range - Ej: 0600, 1200")
        
        st.markdown("---")
        
        st.subheader("‚òÅÔ∏è FEN√ìMENOS Y NUBES")
        fenomeno = st.text_input("Fen√≥meno", key='fenomeno', help="Ej: niebla parcial (PRFG), lluvia ligera (-RA)")
        nubes = st.text_input("Nubes", key='nubes', help="Ej: 8 ST 300M, 5 AC 5000M, CB 1500M")
        
        st.markdown("---")
        
        st.subheader("üå°Ô∏è TEMPERATURA, HUMEDAD Y PRESI√ìN")
        col1, col2, col3, col4, col5 = st.columns(5)
        with col1:
            temp = st.text_input("Temp ¬∞C", key='temp', help="-10 a 40¬∞C")
        with col2:
            rocio = st.text_input("Roc√≠o ¬∞C", key='rocio', help="‚â§ Temperatura")
        with col3:
            hr = st.text_input("HR %", key='hr', help="Humedad Relativa (0-100%)")
        with col4:
            qnh = st.text_input("QNH hPa", key='qnh', help="850-1100 hPa")
        with col5:
            presion = st.text_input("Presi√≥n Est.", key='presion', help="Opcional")
        
        st.markdown("---")
        
        st.subheader("üìù INFORMACI√ìN SUPLEMENTARIA")
        suplementaria = st.text_input("Suplementaria", key='suplementaria', help="Opcional - Ej: RMK CB AL NE")
        
        st.markdown("---")
        
        col1, col2 = st.columns(2)
        with col1:
            generar = st.form_submit_button("üõ´ GENERAR METAR", use_container_width=True)
        with col2:
            limpiar = st.form_submit_button("üßπ LIMPIAR CAMPOS", use_container_width=True)
        
        if limpiar:
            limpiar_campos()
            st.rerun()
        
        if generar:
            datos = {
                'tipo': tipo,
                'dia': dia,
                'hora': hora,
                'dir_viento': dir_viento,
                'int_viento': int_viento,
                'var_viento': var_viento,
                'vis': vis,
                'vis_min': vis_min,
                'rvr': rvr,
                'fenomeno': fenomeno,
                'nubes': nubes,
                'temp': temp,
                'rocio': rocio,
                'hr': hr,
                'qnh': qnh,
                'presion': presion,
                'suplementaria': suplementaria
            }
            
            resultado = generar_metar(datos)
            
            if resultado['success']:
                accion = actualizar_o_insertar_registro(st.session_state.registros, resultado['registro'])
                
                dia_hora_clave = f"{resultado['registro']['D√≠a']}_{resultado['registro']['Hora']}"
                nuevo_historial = []
                
                for metar in st.session_state.historial:
                    match = re.search(r'SPJC (\d{2})(\d{4})Z', metar)
                    if match:
                        dia_hist = match.group(1)
                        hora_hist = match.group(2)
                        if f"{dia_hist}_{hora_hist}" != dia_hora_clave:
                            nuevo_historial.append(metar)
                    else:
                        nuevo_historial.append(metar)
                
                nuevo_historial.insert(0, resultado['metar'])
                st.session_state.historial = nuevo_historial
                st.session_state.contador = len(st.session_state.registros)
                
                if accion == "actualizado":
                    st.warning("üîÑ METAR ACTUALIZADO - Reemplaz√≥ reporte existente con la misma fecha/hora")
                else:
                    st.success("‚úÖ METAR generado correctamente")
                
                st.session_state.ultimo_metar = resultado['metar']
                st.session_state.ultimo_tipo = tipo
            else:
                st.error(f"‚ùå {resultado['error']}")

with col_der:
    st.subheader("üìä METAR GENERADO")
    if 'ultimo_metar' in st.session_state:
        tipo_ultimo = st.session_state.get('ultimo_tipo', 'METAR')
        if tipo_ultimo == "SPECI":
            st.markdown(f"<div style='background: #FFE699; padding: 15px; border-radius: 5px; font-family: monospace; border-left: 5px solid #FFC000;'><b>‚ö†Ô∏è SPECI</b><br>{st.session_state.ultimo_metar}</div>", unsafe_allow_html=True)
        else:
            st.markdown(f"<div style='background: #1e1e1e; color: #00ff00; padding: 15px; border-radius: 5px; font-family: monospace; border-left: 5px solid #0b3d91;'>{st.session_state.ultimo_metar}</div>", unsafe_allow_html=True)
    else:
        st.info("---")
    
    st.markdown("---")
    st.subheader("üíæ EXPORTAR")
    
    if st.button("üì• Exportar Excel", use_container_width=True):
        if st.session_state.registros:
            excel_file, mensaje = exportar_a_excel(st.session_state.registros)
            if excel_file:
                from datetime import datetime
                # NOMBRE DE ARCHIVO: SPJC_METAR_2026_02.xlsx
                fecha_actual = datetime.now()
                nombre_archivo = f"SPJC_METAR_{fecha_actual.strftime('%Y_%m')}.xlsx"
                
                st.download_button(
                    label="üì• Descargar Excel",
                    data=excel_file,
                    file_name=nombre_archivo,
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    use_container_width=True
                )
                st.success(mensaje)
            else:
                st.warning(mensaje)
        else:
            st.warning("‚ö†Ô∏è No hay registros para exportar")
    
    if st.button("üóëÔ∏è Limpiar Memoria", use_container_width=True):
        st.session_state.registros = []
        st.session_state.historial = []
        st.session_state.contador = 0
        st.success("‚úÖ Memoria limpiada")
    
    st.markdown("---")
    st.metric("üìã REGISTROS EN MEMORIA", st.session_state.contador)
    st.markdown("---")
    
    st.subheader("üìú HISTORIAL")
    if st.session_state.historial:
        for metar in st.session_state.historial[:10]:
            if "SPECI" in metar:
                st.markdown(f"<div style='background: #FFE699; padding: 8px; margin-bottom: 5px; border-radius: 3px; font-family: monospace; font-size: 12px; border-left: 3px solid #FFC000;'>{metar}</div>", unsafe_allow_html=True)
            else:
                st.markdown(f"<div style='background: #f0f0f0; padding: 8px; margin-bottom: 5px; border-radius: 3px; font-family: monospace; font-size: 12px; border-left: 3px solid #0b3d91;'>{metar}</div>", unsafe_allow_html=True)
    else:
        st.info("No hay METARs en el historial")

# ============================================
# FOOTER
# ============================================
st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #666; padding: 20px;'>
    <p>‚úàÔ∏è METAR Digital - CORPAC Per√∫ | Aeropuerto Internacional Jorge Ch√°vez (SPJC)</p>
    <p style='font-size: 0.8rem;'>Sistema Profesional de Codificaci√≥n METAR/SPECI</p>
    <p style='font-size: 0.8rem;'>‚úì RVR ‚úì Visibilidad M√≠nima con Cuadrantes ‚úì Variaci√≥n Circular de Viento ‚úì Sin Duplicados ‚úì D√≠a CORREGIDO ‚úì Excel con Hojas por D√≠a</p>
</div>
""", unsafe_allow_html=True)
